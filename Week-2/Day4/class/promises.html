<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.tailwindcss.com"></script>
    <title>ES6 Promises</title>
  </head>
  <body class="bg-gradient-to-r from-gray-100 to-blue-100">
    <div class="conatiner p-4">
      <h1 class="font-bold">Que veremos?</h1>
      <ul class="list-disc p-4">
        <li>Explicar qué es una promesa y por qué se utiliza</li>
        <li>Crear y manejar promesas</li>
        <li>
          Describir los diferentes casos de uso en los que podemos implementar
          promesas
        </li>
      </ul>
    </div>

    <div class="container p-4">
      <h1 class="font-bold">Function expressions</h1>
      <p>
        Como JavaScript es de un solo hilo, sólo puede ocurrir una cosa en un
        momento dado. Para realizar operaciones intensivas y potencialmente
        bloqueantes, utilizamos JavaScript asíncrono.
        <br />
        JavaScript asíncrono es un término utilizado para describir un conjunto
        de técnicas e interfaces utilizadas para realizar tareas que pueden
        bloquear potencialmente el hilo principal y la ejecución del programa.
        Se trata de callbacks, eventos, promesas y async/await. Nos permiten
        ejecutar código de forma asíncrona sin bloquear la ejecución del
        programa.
        <br />
        Ya hemos aprendido cómo se utilizan los callbacks en JavaScript para
        ejecutar código de forma secuencial. Ahora tenemos que aprender cómo
        evitar el infierno de las callbacks y cómo las Promesas pueden ayudarnos
        a resolverlo. Profundizando en la sintaxis y el uso de las Promesas,
        exploraremos cómo utilizarlas para gestionar operaciones de forma
        asíncrona.
      </p>
    </div>

    <div class="container p-4">
      <h1 class="font-bold">Promises</h1>
      <p>
        Una <strong>promesas</strong> es un objeto que representa la
        <strong>finalización o el fracaso</strong> de una
        <strong>operación asíncrona</strong>. Es un objeto especial al que
        puedes adjuntar callbacks, en lugar de pasar callbacks a una función.
        <br />
        La promesa nos permite manejar las
        <strong>operaciones asíncronas</strong> de una manera más
        <strong>sincrónica</strong>.
        <br />
        <strong>Promise</strong> se utiliza para ejecutar código de forma
        asíncrona. El código envuelto en una Promise se ejecuta fuera del hilo
        principal, sin bloquearlo. Por esta razón, muchas APIs web modernas
        utilizan promesas para realizar tareas que consumen tiempo.
      </p>
    </div>

    <div class="container p-4">
      <h1 class="font-bold">Using promises</h1>
      <p>
        Las <strong>promesas</strong> resuelven el problema del infierno de las
        devoluciones de llamada y nos permiten manejar el código de forma
        asíncrona sin bloquear el hilo principal.
        <br />
        Podemos reescribir el ejemplo de callback de la lección anterior
        utilizando promesas asíncronas de la siguiente manera:
      </p>
      <p class="text-xl">After Looking at code!</p>
      <p>
        Las promesas facilitan la comprensión de lo que ocurre. Se garantiza que
        cada operación espera a que una operación anterior termine antes de
        proceder. El código en la promesa se ejecuta de forma asíncrona sin
        bloquear el hilo principal.
      </p>
    </div>

    <div class="container p-4">
      <h1 class="font-bold">Creating a Promise</h1>
      <p>
        Para crear una Promise, utilizamos el nuevo constructor Promise. Acepta
        una función que toma dos funciones de devolución de llamada como
        parámetros:
      </p>
      <ul class="list-disc p-4">
        <li>
          La primera llamada de retorno (normalmente llamada
          <strong>resolve</strong> ) es una función a la que llamar con el valor
          futuro cuando esté listo.
        </li>
        <li>
          La segunda llamada de retorno (normalmente llamada
          <strong>reject</strong> ) es una función a la que se llama para
          rechazar la promesa si no se puede resolver.
        </li>
      </ul>
      <h1 class="font-bold">Promise states</h1>
      <p>Una <strong>promesa</strong> puede tener uno de estos tres estados:</p>
      <ul class="list-disc p-4">
        <li>
          <strong>pending</strong>. Cuando se crea una promesa está en estado
          <strong>pendiente</strong>, hasta que se cumpla o se rechace.
        </li>
        <li>
          <strong>resolved</strong>. Cuando se llama a resolve(), la promesa
          pasa a un estado <strong>cumplido</strong>.
        </li>
        <li>
          <strong>Rejected</strong>Cuando se llama a reject(), o si se lanza un
          error, la promesa pasa a ser <strong>rechazada</strong>.
        </li>
      </ul>
      <p class="uppercase text-xl">
        Una promesa sólo puede ser <strong>liquidada/settled</strong> (es decir,
        cumplida o rechazada) <strong>una vez</strong>.
      </p>

      <p>
        También podemos crear una Promise inmediatamente resuelta o rechazada.
        Para ello utilizamos los métodos Promise.resolve() y Promise.reject()
      </p>
      <p>Vamos al script!</p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Handling Promises</h1>
      <p>
        Una vez que tenemos una Promise, puede ser pasada como un valor. Como
        tal, puede ser devuelta desde una función, pasada como parámetro, y
        utilizada de cualquier otra forma en que se utilizarían los otros
        valores.
      </p>
      <div class="container bg-white rounded-md mx-auto p-4 w-full mt-4">
        <p class="uppercase">important!</p>
        <p>
          La promesa es un sustituto de un valor que estará disponible en en el
          futuro. Utilizamos los métodos promise.then() y promise.catch() para
          asociar otras acciones. Estas acciones se ejecutarán cuando la promesa
          se haya cumplido.
        </p>
      </div>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">.then()</h1>
      <p>
        Para consumir una Promise, adjuntamos un método .then() a la Promise.
        Toma una función a la que se le pasará el valor resuelto de la Promise
        una vez que se cumpla. El método .then() devuelve otra Promise
        pendiente.
      </p>
      <div class="container bg-white rounded-md mx-auto p-4 w-full mt-4">
        <p class="uppercase">important!</p>
        <p>
          Consumir una Promesa significa - procesar el valor de la Promesa una
          vez cumplida.
        </p>
      </div>
      <p>
        Cuando una promesa se resuelve, la función del bloque .then() se
        ejecuta. El valor pasado a la función resolve() se reenvía al bloque
        .then().
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">.catch()</h1>
      <p>
        Para manejar una Promise rechazada - adjuntamos el método .catch() a la
        Promise.
        <br />
        El método .catch() toma una función que recibirá el valor de rechazo una
        vez que la Promise sea rechazada.
      </p>

      <p>
        When a Promise gets rejected the function in the .catch() block runs.
        The value passed to the reject() is forwarded to the .catch() block.
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">ERRORES</h1>
      <p>
        Cuando se lanza un error en una promesa, la promesa se rechaza
        automáticamente.
        <br />
        El error se pasa al bloque .catch() como valor de rechazo.
      </p>

      <p>
        When a Promise gets rejected the function in the .catch() block runs.
        The value passed to the reject() is forwarded to the .catch() block.
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Multiple .then() blocks</h1>
      <p>
        A menudo podemos necesitar realizar dos o más operaciones asíncronas una
        tras otra. Podemos hacerlo encadenando bloques .then().
        <br />
        El truco aquí es el siguiente: el método .then() siempre devuelve una
        promesa. Esto nos permite encadenar bloques .then() uno tras otro.
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Multiple .ctch() blocks</h1>
      <p>
        Podemos tener varios bloques .catch() en la misma cadena de promesas.
        Esto es posible porque el método catch() devuelve una Promise.
        <br />
        Si devuelve algún valor desde el .catch() el valor se convertirá en una
        Promise. Esto permite continuar encadenando bloques .then() después del
        .catch().
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">.finally()</h1>
      <p>
        El método finally() se utiliza para realizar el procesamiento final o la
        limpieza una vez que la promesa se resuelve, independientemente de su
        resultado. El bloque finally() siempre se ejecuta el último,
        independientemente de que la promesa se resuelva o se rechace.
      </p>
    </div>
    <div class="container p-4">
      <h1 class="font-bold">Promise.all()</h1>
      <p>
        Normalmente, creamos cadenas de promesas en las que las operaciones se
        producen una tras otra. ¿Pero qué pasa si queremos ejecutar algún código
        sólo después de que se hayan cumplido varias promesas?
        <br />
        Esto se puede hacer utilizando el método Promise.all(). Este método se
        utiliza para agregar los resultados de múltiples promesas.
        <br />
        El método Promise.all() toma un array de promesas como argumento.
        Devuelve una única promesa que se resuelve cuando todas las promesas del
        argumento del array se han resuelto.
      </p>
      <h1 class="font-bold text-sm">Fulfillment</h1>
      <ul>
        <li>
          La promesa devuelta por Promise.all() se cumplirá sólo cuando todas
          las promesas del array se hayan resuelto.
        </li>
        <li>
          Cuando la promesa devuelta se resuelve, devuelve un array. El array
          contendrá los resultados de las promesas de entrada.
        </li>
      </ul>
      <p>
        Si se pasa un array vacío, Promise.all() devuelve inmediatamente una
        Promise cumplida.
      </p>
      <h1 class="font-bold text-sm">Rejection</h1>
      <p>
        Si alguna de las promesas pasadas es rechazada, Promise.all rechaza
        asíncronamente con el valor de la promesa que rechazó,
        independientemente de que las otras promesas se hayan resuelto o no.
      </p>
    </div>

    <div class="container p-4">
      <h1 class="font-bold">En Resumen</h1>
      <p>
        Las promesas nos permiten escribir código asíncrono de forma sincrónica
        y lineal. Como muchas APIs web modernas utilizan promesas, es esencial
        saber cómo trabajar con ellas.
        <br />
        Para crear una Promise utilizamos el nuevo constructor Promise, que toma
        una función con dos callbacks: resolve y reject. Una Promise puede estar
        en uno de estos tres estados: pendiente, cumplida o rechazada.
        <br />
        Especificamos cómo debe manejarse la Promesa utilizando los métodos
        then() y catch().
        <br />
        El método then() se ejecuta cuando una Promise se cumple con éxito (se
        resuelve). El método catch() se ejecutará cuando la Promise sea
        rechazada, debido al rechazo o a un Error. Para manejar Promesas
        consecutivas podemos encadenar múltiples bloques then() y catch(). br
        Por último, podemos utilizar el método finally() para hacer la limpieza
        final una vez que la Promesa se haya resuelto. Para agregar los
        resultados y esperar a que se cumplan muchas promesas, utilizamos el
        método Promise.all().
      </p>
    </div>

    <script>
      const directions = [
        "Compra Ron del bueno, preferible santa teresa, zacapa, nada de Bacardi porfavor",
        "Compra Coca-Cola y Hielo",
        "Mezcla 3/4 de Ron con 1/3 de Cocacola en un vaso con hielo",
        "Disfruta tu cubata bien frio en este verano",
      ];

      const howToMakeAcubata = (step) => {
        // setTimeout(() => {
        return new Promise((resolve, reject) => {
          console.log(directions[step]);
          if (!directions[step]) reject("Instructions not found.");
          else resolve();
          // }, 2000);
        });
      };

      howToMakeAcubata(0)
        .then(() => howToMakeAcubata(1))
        .then(() => howToMakeAcubata(2))
        .then(() => howToMakeAcubata(3))
        .then(() =>
          console.log("Por favor siempre recuerda de beber con moderación.")
        )
        .catch((err) => console.log(err));

      //CREANDO UNA PROMESA
      //         const myPromise = new Promise( (resolve, reject) => {
      //    if (/* condition */) {
      //       resolve(/* value */);  // fulfilled successfully
      //    }
      //    else {
      //       reject(/* reason */);  // error, rejected
      //    }
      // });

      // Using direct promises -JUST EXAMPLE-
      const promisePending = new Promise((resolve, reject) => {});
      const promiseResolved = Promise.resolve(42);
      //   const promiseRejected = Promise.reject("We rejected it");

      console.log(promisePending);
      console.log(promiseResolved);
      //   console.log(promiseRejected);

      //USING .then en una promesa
      const pr1 = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve("Ironhack");
        }, 2000);
      });

      pr1.then((val) => console.log("Resolved with: ", val));

      // Using .catch() en una promesa
      const pr2 = new Promise((resolve, reject) => {
        setTimeout(() => {
          reject("Rejected!"); // <== This value will be passed to catch()
        }, 2000);
      });

      pr2
        .then((value) => console.log("Resolved with: ", val))
        .catch((err) => console.log("catch() -> ", err));

      // Showcasin Errors
      const pr3 = new Promise((resolve, reject) => {
        throw new Error("Rejected by throwing an Error!");
      });

      pr3
        .then((value) => console.log("Resolved with: ", value))
        .catch((err) => console.log("catch() -> ", err));

      //using multiples .then en una promesa
      const pr5 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("A"), 2000);
      });

      pr5
        .then((value1) => {
          console.log("value1:", value1);
          return "B";
        })
        .then((value2) => {
          console.log("value2:", value2);
          return "C";
        })
        .then((value3) => {
          console.log("value3:", value3);
          return "D";
        })
        .then((value4) => {
          console.log("value4:", value4);
        });

      //Podemos actualizar el ejemplo anterior para crear un escenario más realista. Podemos actualizar cada bloque then() para que devuelva una Promise que se resuelva de forma asíncrona, después de 2000 milisegundos:
      const pr6 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("A"), 2000);
      });

      pr6
        .then((value1) => {
          console.log("value1:", value1);
          return new Promise((resolve, reject) =>
            setTimeout(() => resolve("B"), 2000)
          );
        })
        .then((value2) => {
          console.log("value2:", value2);
          return new Promise((resolve, reject) =>
            setTimeout(() => resolve("C"), 2000)
          );
        })
        .then((value3) => {
          console.log("value3:", value3);
          return new Promise((resolve, reject) =>
            setTimeout(() => resolve("D"), 2000)
          );
        })
        .then((value4) => {
          console.log("value4:", value4);
        });

      //using multiples .catch en una promesa
      //   const pr7 = new Promise((resolve, reject) => {
      //     setTimeout(() => resolve("A"), 2000);
      //   });

      //   pr7
      //     .then((value1) => {
      //       console.log("1. then(): ", value1);
      //       throw new Error("FIRST ERROR");
      //     })
      //     .catch((err) => {
      //       console.error("1. catch(): ", err);
      //       return "Hello from catch";
      //     })
      //     .then((value2) => {
      //       console.log("2. then(): ", value2);
      //       throw new Error("SECOND ERROR");
      //     })
      //     .catch((err) => {
      //       console.error("2. catch(): ", err);
      //     });

      // using .finally en un promise
      const pr8 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("A"), 2000);
      });

      pr8
        .then((value1) => console.log("1. then()"))
        .then((value2) => console.log("2. then()"))
        .finally(() => {
          console.log("finally()");
        });

      // otro ejemplo con .finally
      const pr9 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("Ironhack"), 2000);
      });

      pr9
        .then(() => console.log("1. then()"))
        .then(() => Promise.reject("Oops!")) // <= Reject a Promise
        .then(() => console.log("3. then()")) // <= This block is skipped
        .catch((err) => {
          console.log("catch()", err);
        })
        .finally(() => console.log("finally()"));

      // Promise all
      const p1 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("foo"), 1000);
      });

      const p2 = new Promise((resolve, reject) => {
        setTimeout(() => resolve(1337), 2000);
      });

      const p3 = new Promise((resolve, reject) => {
        setTimeout(() => resolve({ name: "Bob" }), 4000);
      });

      Promise.all([p1, p2, p3]).then((values) => console.log("values", values));

      // pasando un empty array para ver que sale fulfilled
      const p4 = Promise.all([]);

      console.log(p4);

      // poniendo una parte de la promesa como rejected
      const p5 = new Promise((resolve, reject) => {
        setTimeout(() => resolve("foo"), 1000);
      });

      const p6 = new Promise((resolve, reject) => {
        setTimeout(() => resolve(1337), 2000);
      });

      const p7 = new Promise((resolve, reject) => {
        setTimeout(() => reject("Something went wrong"), 4000); // <= Reject the promise
      });

      Promise.all([p5, p6, p7])
        .then((values) => console.log("values", values))
        .catch((err) => console.log("catch()", err));
    </script>
  </body>
</html>
